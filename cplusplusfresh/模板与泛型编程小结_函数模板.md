### 模板与泛型编程小结 --- 函数模板 ###
-----------------------------------

我们可以定义一个通用的函数模板（function template），而不是为每个类型都定义一个新函数。

	template <typename T>
	int compare(const T &v1, const T &v2)  // 使用const引用是保证函数可以用于不能拷贝的类型
	{
		if (v1 < v2) return -1;
		if (v1 > v2) return 1;
		return 0;
	}
	
**当我们调用一个函数模板时，编译器用函数实参来为我们推断模板实参**。

	cout << compare(1, 0) << endl;   // T被推断为int
	
我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。

除了定义类型参数，还可以在模板中定义**非类型参数（nontype parameter）**。

**一个非类型参数表示一个值而非一个类型**。当一个模板被实例化时，**非类型参数被一个用户提供的或编译器推断出的值所代替**，这些值必须是**常量表达式**，从而允许编译器在编译时实例化模板。

	template <unsigned N, unsigned M>
	int compare(const char (&p1)[N], const char (&p2)[M])
	{
		return strcmp(p1, p2);
	}
	
我们可以这样使用：
	
	compare("hi", "mom");

编译器会使用字面常量的大小来代替N和M（自动加终结符），从而实例化模板。因此编译器会实例化以下版本：

	int compare(const char (&p1)[3], const char (&p2)[4]);
	
当编译器遇到一个模板定义时，它并不生成代码。**只有当我们实例化出模板的一个特定版本时，编译器才会生成代码**。

为了实例化模板，编译器需要掌握函数模板或类模板成员函数的定义，因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。通常，**大多数编译错误发生在实例化期间**。
