### C++11 知识点小结 ###
----------------------
#### auto 类型指示符 ####

**需求：**编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型（因为C++是静态语言），然而要做到这一点并非那么容易，有时甚至根本做不到。
	
为了解决这个问题，C++11新标准引入了`auto`类型说明符，**用它就能让编译器替我们去分析表达式所属的类型**。`auto`让**编译器通过初始值来推算变量的类型**。
	
> **---> auto 定义的变量必须有初始值，这样才能给编译器提供推导的依据**；
		
	auto item = val1 + val2;   // item 初始化为val1和val2相加的结果
		
> **---> auto 也能在一条语句中声明多个变量，但是一条语句中只能有一个基本数据类型，
		    即该语句中所有变量的初始类型都必须一样**；
		
	auto i = 0, *p = &i;       // correct
	auto sz = 0, pi = 3.14;    // error, sz is integer but pi is float
		
> **---> 编译器会以引用对象的类型作为auto的类型**
	
使用引用其实是使用引用的对象，特别是当引用被用作初始值，真正参与初始化的其实是引用对象的值。
	
	int i = 0, &r = i;
	auto a = r;                // a是一个整数

> **---> auto会忽略掉顶层const，保留底层const**
	
	const int ci = i, &cr = ci;
	auto b = ci;              // b是一个整数，顶层const被忽略了
	auto e = &ci;             // e是一个指向整数常量的指针。因为对常量对象取地址意味着需要生成
		                      // 一个指向常量对象的指针，具有底层const属性
		                          
**如果希望推断出的auto类型是一个顶层const**，需要明确指出：
	
	const auto f = ci;        // ci的推演类型是int，f是const int
		
>**---> 可以将引用类型设置为auto，此时初始值中的顶层常量属性仍然保留**
	
	auto &g = ci;             // g是一个整型常量引用，绑定到ci
	auto &h = 42;             // error，不能为非常量引用绑定字面值
	const auto &j = 42;       // correct，可以为常量引用绑定字面值
