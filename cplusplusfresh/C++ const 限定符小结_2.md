### C++ const 限定符小结 ###
--------------------------
### 2. const的引用 ###
可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为**对常量的引用(reference to const)**。
与普通引用不同的是，对常量的引用不能修改它所绑定的对象。

	const int ci = 1024;
	const int &r1 = ci;   // correct，引用其对应的对象都是常量
	r1 = 42;              // error
	int &r2 = ci;         // error，试图让一个非常量引用指向一个常量对象
	
> **---> 不能让一个非常量引用指向一个常量对象**

假设这个初始化合法，那么就可以通过这个非常量引用来改变它所引用的值。

> **---> 初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可**

本来，引用的类型必须与其引用对象的类型一致，但上述是一个例外。

	// 以下行为是合法的
	double dval = 3.14;
	const int &ri = dval;
	
	// 以下行为是非法的
	double dval = 3.14;
	int &ri = dval;
	
其实，这里发生了这么一个过程：

	const int temp = dval;  // 由双精度浮点数生成一个临时的整型常量
	const int &ri = temp;   // 让ri绑定这个临时量
**在这种情况下，ri绑定了一个临时量对象。**

所谓临时量就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名对象。现在探讨当ri不是常量时，如果执行了类似于上面的初始化过程将带来什么样的后果。如果ri不是常量，就允许对ri赋值，这样就会改变ri所引用对象的值。注意，此时绑定的对象是一个临时量而非dval。程序员既然让ri引用dval，就肯定想通过ri改变dval的值，否则干什么要给ri赋值呢？如此看来，既然大家基本上不会想着把引用绑定到临时量上，C++语言也就把这种行为归为非法。


> **---> 对const的引用可以绑定一个非const对象[非常重要]**

**常量引用仅对引用可参与的操作做出了限定，对于引用对象本身是不是常量未做假定。**因为对象可能是个非常量，所以允许通过其他途径改变它的值。

	int i = 42;
	int &r1 = i;
	const int &r2 = i; // 不允许通过r2来修改i的值
	r1 = 0;    // correct
	r2 = 0;    // error

	
